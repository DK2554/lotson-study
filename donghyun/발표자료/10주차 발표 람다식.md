## 🤗람다식(Lambda expression)

자바가 1996 등장한 이후 2번의 큰변화
1.JDK 1.5부터 추가된 generics 제네릭스의 등장
2.JDK 1.8부터 추가된 람다식(Lambda expression) 추가

람다식의 도입 -> 객체지향언어 && 함수형 언어

#### 함수형 언어란? 

#### 람다식이란?
메서드를 하나의 식(expression)으로 표현한것
#### 특징
함수를 간략하면서도 명확한 식으로 표현
메서드 이름, 반환값 없어짐 -> 익명함수라고도 함
```
int[] arr = new int[5];
Arrays.setAll(arr, (i)->(int)(Math.random()*5)+1;
```


```
(i)->(int)(Math.random()*5)+1  // 람다식

int method(){  //기존 함수
	return (int)(Math.random()*5)+1; 
}

```

### 장점:
1.기존의 모든 메서드는 클래스에 포함해야 하므로 메서드를 만들때 클래스생성 + 메서드 생성--> 람다식 자체로 메서드 역할 가능
2.메서드를 변수처럼 다루는 것이 가능

> 
메서드와 함수의 차이<br>
전통적으로 프로그래밍에서 함수라는 이름은 수학에서 따온 것이다.
수학의 함수와 개념이 유사하기 때문이다.<br>
그러나 객체지향개념에서는 함수(function) 대신 객체의 행위나 동작을 의미하는 메서드(method) 라는 용어를 사용한다.
메서드는 함수와 같은 의미이지만, 특정 클래스에 반드시 속해야 한다는 제약이 있기 때문에 기존의 함수와 같은 의미를 다른 용어를 선택해서 사용한 것이다.<br>
그러나 이제 다시 람다식을 통해 메서드가 하나의 독립적인 기능을 하기 때문에 함수라는 용어를 사용하게 되었다.


#### 람다식 작성하기
>람다식은 '익명 함수' 답게 메서드에서 이름과 반환타입을 제거하고 매개변수 선언부와 몸통{} 사이에 '→' 를 추가한다.

```
반환타입 메서드이름(매개변수 선언){
	문장들
}

(매개변수 선언) -> {
	문장들
}

ex)

int max(int a, int b){
	return a> b ? a: b;
}

(int a, int b) -> { return a > b ? a: b; }
```
####  반환값이 있는 메서드의 경우
- **return 문 대신 '식(expression)' 으로 대신할 수 있다.**
- 식의 연산결과가 자동적으로 반환값이 된다.
```
(int a, int b) -> a > b ? a: b
```

- 선언된 매개변수의 타입은 추론이 가능한 경우 생략할 수 있다.
- 람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문이다.
```
(a, b) -> a > b ? a : b
```

- 선언된 매개변수가 하나인 경우 괄호() 를 생략할 수 있다.
- 단, 매개변수의 타입이 있으면 괄호()를 생략할 수 없다.
```
a -> a * a // OK
int a -> a * a // Error
```

- 괄호{} 안의 문장이 하나일 때는 괄호{}를 생략할 수 있다.
- 문장의 끝에 ';'을 붙이지 않아야 한다는 것에 주의한다.
```
(Strring name, int i) -> { System.out.println(name+"="+i); }

(String name, int i) -> System.out.println(name+"="+i)
```

## 함수형 인터페이스 (Functional Interface)

자바에서 모든 메서드는 클래스 내에 포함되어야 하는데,

*람다식은 어떤 클래스에 포함되는 것일까?*

**람다식은 익명 클래스의 객체와 동등하다.**

```
(int a, int b) -> a > b ? a : b

// 위(람다식)와 아래(익명 클래스의 객체 내부 메소드)와 같다

new Object(){
	int max(int a, int b){
		return a > b ? a : b;
	}
}

```
위 익명 클래스 내부의 max 메소드명은 임의로 붙인 것이지 의미없다.

그렇다면, 람다식으로 정의된 익명 객체의 메서드를 어떻게 호출할 수 있을 것인가?

- 참주변수가 있어야 객체의 메서드를 호출할 수 있으니 이 익명 객체의 주소를 f 라는 참조변수에 저장해본다.

```
타입 f = (int a, int b) -> a > b ? a : b;  // 여기서 참조변수 f의 타입은???
```

- 참조변수 f의 타입은 어떤 것이어야 할까?
    - 참조형이니깐 클래스 또는 인터페이스가 가능하다.
- 그리고 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다.
    - 그래야만 참조변수로 익명 객체(람다식)의 메서드를 호출할 수 있기 때문이다.
    
위 내용을 바탕으로 예를 들어 max()라는 메서드가 정의된 MyFunction 인터페이스가 정의되어 있다고 가정해본다.

```
interface MyFunction{
	public abstract int max(int a, int b);
}
```
위 인터페이스를 구현한 익명 클래스의 객체는 아래와 같이 생성가능하다.
```
MyFunction f = new MyFunction(){
	public int max(int a, int b){
		return a > b ? a: b;
	}
}

int big = f.max(5, 3);
```

여기서 MyFunction인터페이스에 정의된 메서드 max() 는 

***람다식 '(int a, int b) → a > b ? a: b'*** 와 일치한다.

→ 익명 객체를 담다식으로 아래와 같이 대체할 수 있다.

```
MyFunction f = (int a, int b) -> a > b ? a : b;   // 익명 객체를 람다식으로 대체
int big = f.max(5,3); // 익명 객체의 메서드를 호출 


```
위와 같이 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체할 수 있는 이유는

***람다식도 실제로는 익명 객체이고, MyFunction 인터페이스를 구현한 익명 객체의 메서드 max()와 람다식의 매개변수 타입과 개수 그리고 반환값이 일치하기 때문이다.***

하나의 메서드가 선언된 인터페이스를 정의해서

람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다.

- 그렇기 때문에 인터페이스를 통해 람다식을 다루기로 결정되었으며,
- ***람다식을 다루기 위한 인터페이스를 함수형 인터페이스(functional interface)라 부르기로 했다.***

```
@FunctionalInterface
interface MyFunction{
	public abstract int max(int a, int b);
}
```

**단, 함수형 인터페이스에서는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다.**

- 그래야 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문이다.
- 다만, static 메서드와 default 메서드의 개수에는 제약이 없다.
- *함수형 인터페이스로 구현한 인터페이스라면 반드시 '**@FunctionalInterface**' 애노테이션을 정의하도록 하자.*
    - 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해주니깐 🙂
    
```
List<String> list = Arrays.asList("abc","aaa","bbb","ccc","aaa);

Collections.sort(list,new Comparatior<String>(){
	public int compare(String s1, String s2){
    	return s2.compareTo(s1);
    }
}

List<String> list = Arrays.asList("abc","aaa","bbb","ccc","aaa);
Collections.sort(listm, (s1, s2) -> s2.compareTo(s1));
```

## 함수형 인터페이스 (Functional Interface)

- 추상 메소드를 딱 하나만 가지고 있는 인터페이스
- SAM(Single Abstract Method) 인터페이스
- **@FunctionalInterface** 에노테이션을 가지고 있는 인터페이스

## 람다 표현식 (Lambda Expressions)

- 함수형 인터페이스의 인스턴스를 만드는 방법으로 쓰일 수 있다.
- 코드를 줄일 수 있다.
- 메소드 매개변수, 리턴파입, 변수로 만들어 사용할 수 있다.

## 자바에서 함수형 프로그래밍

- 함수를 First Class Object로 사용할 수 있다.
- **순수 함수 (Pure Function)**
    - 사이드 이팩트 만들 수 없다. (함수 밖에 있는 값을 변경하지 못한다.)
    - 상태가 없다. (함수 밖에 정의되어 있는)
- **고차 함수 (High-Order Function)**
    - 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수 있다.
    
추상 메소드 하나만 있으면 함수형 인터페이스이다.
```

package me.ssonsh.java8to11;

@FunctionalInterface
public interface RunSomething {
    void doIt();
}

```

>→ @FunctionalInterface 애노테이션을 정의하고 나서 추가적인 추상 메서드를 입력하면, 컴파일 시 에러가 발생된다. (why? 함수형 인터페이스가 아니게 됨으로)

### Java에서 기본으로 제공하는 함수형 인터페이스

- **Java.lang.function 패키지**
- 자바에서 미리 정의해둔 자주 사용할만한 함수 인터페이스
    - Function<T, R>
    - BiFunction<T, U, R>
    - Consumer<T>
    - Supplier<T>
    - Predicate<T>
    - UnaryOperator<T>
    - BinaryOperator<T>
    - ....
    

### Function<T, R>

값을 하나 받아서 리턴하는 일반적인 함수

```jsx
R apply<T>
```

[Plus10.java](http://plus10.java) Class → **implements Function<Integer, Integer>**

- Integer값을 받아서 Integer 값으로 반환하고자 함.

```jsx
package me.ssonsh.java8to11;

import java.util.function.Function;

public class Plus10 implements Function<Integer, Integer> {
    @Override
    public Integer apply(Integer integer) {
        return integer + 10;
    }
}
```

Use Plus10.java

```jsx
package me.ssonsh.java8to11;

public class Foo {

    public static void main(String[] args){

        Plus10 plus10 = new Plus10();
        System.out.println(plus10.apply(1));
    }
}
```

**plus.**

위와 같은 동작을 하는 함수를 Plus10.java라는 별도 클래스 없이도 사용할 수 있다.

- Function<Integer, Integer> 함수형 인터페이스를 바로 구현

```jsx
package me.ssonsh.java8to11;

import java.util.function.Function;

public class Foo {

    public static void main(String[] args){
        Function<Integer, Integer> plus10 = (number) -> number + 10;
        System.out.println(plus10.apply(1));
    }
}
```

**함수의 조합도 가능하다.**

- **compose**
    - 입력값을 가지고 먼저 뒤에 오는 함수를 적용한다.
    - 그 결과값을 다시 입력값으로 사용하는 것이다.
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Function;
    
    public class Foo {
    
        public static void main(String[] args){
            Function<Integer, Integer> plus10 = (number) -> number + 10;
            Function<Integer, Integer> multiply2 = (number) -> number * 2;
    
            System.out.println(plus10.apply(1));
            System.out.println(multiply2.apply(1));
    
            Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiply2);
            System.out.println(multiply2AndPlus10.apply(2));
        }
    }
    ```
    
- **andThen**
    - compose와 반대로 먼저 적용하고 뒤에 오는 함수를 적용한다.
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Function;
    
    public class Foo {
    
        public static void main(String[] args){
            Function<Integer, Integer> plus10 = (number) -> number + 10;
            Function<Integer, Integer> multiply2 = (number) -> number * 2;
    
            System.out.println(plus10.apply(1));
            System.out.println(multiply2.apply(1));
    
            Function<Integer, Integer> plus10AndMultiply2 = plus10.andThen(multiply2);
            System.out.println(plus10AndMultiply2.apply(2));
    
        }
    }
    ```
    

### BiFunction<T, U, R>

- Function<T, R> 과 유사하지만, 입력값을 2개를 받는 것이다.
    
    (T, U) → R
    
    ```jsx
    R apply(T t, U u)
    ```
    

### Consumer<T>

- 리턴이 없다. | 함수 조합용 메소드 : andThen
    
    ```jsx
    void Accept(T t)
    ```
    

- Consumer<T> 함수형 인터페이스 사용 예시
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Consumer;
    
    public class Foo {
    
        public static void main(String[] args){
            Consumer<Integer> printT = System.out::println;
            printT.accept(10);
        }
    }
    ```
    

### Supplier<T>

- T 타입의 값을 제공해주는 함수형 인터페이스
    
    ```jsx
    T get()
    ```
    
- Supplier<T> 사용 예시
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Supplier;
    
    public class Foo {
    
        public static void main(String[] args){
            Supplier<Integer> get10 = () -> 10;
            System.out.println(get10.get());
        }
    }
    ```
    

### Predicate<T>

- T 타입의 값을 받아서 boolean 을 반환하는 함수 인터페이스
    
    ```jsx
    boolean test(T t)
    ```
    
- 함수 조합용 메소드
    - And, Or, Negate

- Predicate<T> 사용 예시
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Predicate;
    
    public class Foo {
    
        public static void main(String[] args){
            Predicate<String> startsWithSson = (str) -> str.startsWith("sson");
            Predicate<Integer> isEven = (i) -> i % 2 == 0;
        }
    }
    ```
    

### UnaryOperator<T>

- Function<T, R>의 특수한 형태
- 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스
- 입력/리턴 값이 같으므로 이전의 Function<T, R> 을 아래와 같이 변경할 수 있다.
    
    ```jsx
    package me.ssonsh.java8to11;
    
    import java.util.function.Function;
    import java.util.function.UnaryOperator;
    
    public class Foo {
    
        public static void main(String[] args){
            // Function<Integer, Integer> plus10 = (number) -> number + 10;
            UnaryOperator<Integer> plus10 = (number) -> number + 10;
    
            // Function<Integer, Integer> multiply2 = (number) -> number * 2;
            UnaryOperator<Integer> multiply2 = (number) -> number * 2;
    
        }
    }
    ```
    

### BinaryOperator<T>

- BiFunction<T, U, R> 의 특수한 형태
- 동일한 타입의 입력값 2개를 받아서 리턴하는 함수 인터페이스
- 3개의 타입이 다 같을 것이라는 가정으로 작성됨.
  
> 출처:https://www.notion.so/758e363f9fb04872a604999f8af6a1ae
  출처: 자바의 정석
  원본:https://velog.io/@kdong702/%EB%9E%8C%EB%8B%A4%EC%8B%9DLambda-expression

