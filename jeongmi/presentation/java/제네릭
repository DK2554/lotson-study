# 제네릭

원본 링크: [https://dawn-boursin-991.notion.site/d43a9a43833e4269a50e42a900f56c3f](https://www.notion.so/6e574db429a1401386248e2f607a7bb8)

## 💡 제네릭(generic)이란?

다양한 타입의 객체에 재사용성을 높일 수 있는 기법으로, 클래스에 사용할 타입을 외부에서 설정하는 것을 말한다.

제네릭을 사용하지 않을 경우 빈번한 타입 변환이 발생할 수 있으며, 이는 프로그램의 성능을 저하시키는 원인이 된다.

## 💡 제네릭(generic) 사용법

```java
// 제네릭 사용 전
public class Car {
	private Object obj;
	public void set(Object obj) {this.obj = obj;}
	public Object get() {return obj;}
}

Car car = new Car();
car.set("Black");
String color = (String)car.get(); // get 해 올 때 타입 변환을 해 주어야 함.
```

```java
// 제네릭 사용 후
public class Car<T> {
	private T t;
	public void set(T t) {this.t = t;}
	public T get() {return t;}
}

Car<String> car1 = new Car<String>();
car1.set("Black");
String color = car1.get();

Car<Integer> car2 = new Car<Integer>();
car2.set(3);
int column = car2.get();
```

## 💡 바운디드 타입

**타입 변수 T 에 지정할 수 있는 타입의 종류를 제한하는 것**을 **바운디드 타입**이라고 한다.

```java
class FruitBox<T extends Fruit> {} // Fruit 클래스를 상속한 클래스만 대입할 수 있다.
```

```java
interface Eatable {}
class FruitBox<T extends Eatable> {} 
// Eatable 인터페이스를 구현한 클래스만 대입할 수 있다.
// 인터페이스를 구현한 클래스를 대입할 때에,
// ‘implements’ 가 아닌 ‘extends’ 를 사용한다는 것에 주의하자.
```

```java
class FruitBox<T extends Fruit & Eatable> {}
// Fruit 클래스를 상속하면서, Eatable 인터페이스를 구현한 클래스만 대입하고 싶을 때에는
// 위와 같이 기재한다. 
```

## 💡 와일드 카드

와일드 카드는 제네릭의 하위 개념으로 **?** 로 표시되며 알 수 없는 유형을 참조하는 데 사용한다. 어떤 타입이든 올 수 있다는 말이다.

그렇다면 와일드카드와 제네릭의 차이점은 무엇인가?

|  | 1) 바운드 | 2) 멀티 바운드 |
| --- | --- | --- |
| 제네릭 | 하위만 가능 | 가능 |
| 와일드카드 | 상위, 하위 모두 가능 | 불가능 |

1) 바운드(bounds, 제한)

```java
// 제네릭은 extends, 즉 하위 바운드만 가능. Number 의 자손만 올 수 있다.
public static void printList(List<T extends Number> list)

// 와일드카드는 super, extends 모두 가능.
public static void printList(List<? super Integer> list) // Integer 의 조상만 올 수 있다.
public static void printList(List<? extends Number> list) // Number 의 자손만 올 수 있다.
```

2) 멀티 바운드(multi bounds, 다중 제한)

```java
<T extends Number & Comparable>
```

## 💡 제네릭 메소드

```java
public static Box<T> makeBox(T o) {...}
```

클래스 전부가 아닌 일부 메소드에 대해서 제네릭으로 정의하는 것이 가능하다. 인스턴스 메소드뿐만 아니라 클래스 메소드에 대해서도 정의가 가능. 이렇게 정의된 메소드를 가리켜 제네릭 메소드 라고 한다.

그러나 위의 메소드 정의는 완전하지 않으며, 해당 메소드를 컴파일할 시 컴파일러는 T 를 인식하지 못하고 컴파일 에러를 일으킨다.

```java
public static <T> Box<T> makeBox(T o){...}
```

반환형 앞에 <T> 를 명시해 줌으로써, 컴파일러가 <T> 를 타입 매개변수로 인식하도록 할 수 있다.

## 💡 타입 소거(Type Erasure)

제네릭의 타입 소거는 컴파일 시 타입 체크를 해서 타입이 안 맞는 것을 잡아낸 후 컴파일 에러를 발생시키고 문제없이 컴파일 됐다면 런타임 중에는 타입 정보를 전부 버리는 것이다. 과거 제네릭이 없던 버전과의 하위 호환성을 위해서이다.

```java
// 타입소거 전
class GenericClass <T> {

    public void consume(T paramenter) {
        paramenter.toString();
    }
}

// 타입소거 후
class GenericClass {

    public void consume(Object paramenter) {
        paramenter.toString();
    }
}
```

컴파일러는 Unbound type 에 대하여 Object 로 바꿔버렸다. 따라서 런타임에는 해당 타입이 본래 어떤 타입이었는지 알 수 없다. 타입 소거에 대한 동작은 다음과 같다.

- Unbound type 의 경우 Object, bound type 의 경우 bound 값을 기준으로 타입을 바꾼다.
- 필요에 따라 캐스팅 및 bridge 메소드가 추가될 수 도 있다.

*추가

HashMap<K, V> 컬렉션은 경로명이 java.util.HashMap이며, '키(key)'와 '값(value)'의 쌍으로 구성되는 요소를 다룬다. k는 '키'로 사용할 데이터 타입을, v는 '값'으로 사용할 데이터 타입의 타입매개변수이다.

컬렉션이란?

컬렉션은 배열이 가진 고정 크기의 단점을 극복하기 위해 객체들을 쉽게 삽입, 삭제, 검색할 수 있는 가변 크기의 컨테이너이다. 컬렉션 클래스는 개발자가 바로 사용할 수 있는 것들로서, Vector<E>와 ArrayList<E>는 가변 크기의 배열을 구현하며, LinkedList<E>는 노드들이 링크로 연결되는 리스트를 구현한다. Stack<E>는 스택을 구현하며 HashSet<E>는 집합을 구현한다. 이들은 모두 Collection<E>를 상속받고, 단일 클래스의 객체만을 요소로 다루는 공통점이 있다. HashMap<K,V>는 키(K)와 값(V)의 쌍으로 이루어지는 데이터를 저장하고, 키로 쉽게 검색하도록 만든 컬렉션이다.

컬렉션의 특징

첫째, 컬렉션은 제네릭 이라는 기법으로 만들어져있다.

컬렉션 클래스의 이름에는 <E>,<K>,<V>등이 항상 포함된다. 이들은 타입 매개 변수 라고 하며 Vector<E>에서 E 대신 Integer와 같이 구체적인 타입을 지정하면 Vector<Integer>는 정수 값만 저장하는 벡터로, Vector<String>문자열만 저장하는 벡터로 사용할 수 있다. 특정 타입만 다루지 않고 여러 종류의 타입으로 변신할 수 있도록 컬렉션을 일반화 시키기 위해 <E>를 사용하는 것이다. 그러므로 E를 일반화 시킨 타입 혹은 제네릭 타입(generic type)이라고 부른다. 컬렉션은 여러 타입의 값을 다룰 수 있도록 변신이 가능한 자료 구조 이지만, 컬렉션을 사용할 때는 지정된 특정 타입의 값만 저장 가능하다.

둘째, 컬렉션의 요소는 객체들만 가능하다. int , char, double등의 기본타입의 데이터는 원칙적으로 컬렉션의 요소로 들어가지 못한다.

```
Vector<int> v = new Vector<int>();  // int로 생성 불가능
Vector<Integer> v = new Vector<Integer>(); // 정상적으로 생성
```

하지만 기본 타입의 값이 삽입되면 자동 박싱에 의해 Wrapper 클래스 타입으로 변환되어 객체로 저장한다.

---

[참고 자료]